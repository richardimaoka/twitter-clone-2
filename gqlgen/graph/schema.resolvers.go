package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"time"

	"github.com/google/uuid"
	"github.com/richardimaoka/twitter-clone-2/gqlgen/graph/model"
)

// PostTweet is the resolver for the postTweet field.
func (r *mutationResolver) PostTweet(ctx context.Context, body string) (*model.Tweet, error) {
	tweetId := uuid.New().String()
	userName := "リチャード 伊真岡"
	userId := "richardimaoka"
	profilePicture := "/images/richard-picture.png"
	timeStamp := time.Now()
	time := fmt.Sprintf("%d時%d分", timeStamp.Hour(), timeStamp.Minute())
	date := fmt.Sprintf("%d年%d月%d日", timeStamp.Year(), timeStamp.Month(), timeStamp.Day())

	newTweet := model.Tweet{
		ID:             &tweetId,
		UserName:       &userName,
		UserID:         &userId,
		ProfilePicture: &profilePicture,
		Body:           &body,
		// PicturePath
		// PictureWidth
		// PictureHeight
		TimeStamp: &timeStamp,
		Time:      &time,
		Date:      &date,
		// Retweets
		// Quotes
		// Likes
		// Bookmarks
		// Replies
		// Impressions
	}

	r.Resolver.allTweets = append([]*model.Tweet{&newTweet}, r.Resolver.allTweets...)
	fmt.Println("len all tweets = ", len(r.Resolver.allTweets))
	return &newTweet, nil
}

// Like is the resolver for the like field.
func (r *mutationResolver) Like(ctx context.Context, tweetID string) (*model.Tweet, error) {
	log.Printf("like on tweetID = %v", tweetID)
	for _, t := range r.Resolver.allTweets {
		if t.ID != nil && *t.ID == tweetID {
			log.Printf("incrementing like = %d", *t.NumLikes)
			likes := *t.NumLikes
			likes++
			t.NumLikes = &likes
			return t, nil
		}
	}
	return nil, fmt.Errorf("tweet not found")
}

// Tweet is the resolver for the tweet field.
func (r *queryResolver) Tweet(ctx context.Context) (*model.Tweet, error) {
	bytes, err := os.ReadFile("data/tweet.json")
	if err != nil {
		return nil, err
	}

	var tweet model.Tweet
	err = json.Unmarshal(bytes, &tweet)
	if err != nil {
		log.Printf("Error in Tweet - %v", err)
		return nil, fmt.Errorf("internal server error")
	}

	return &tweet, nil
}

// Timeline is the resolver for the timeline field.
func (r *queryResolver) Timeline(ctx context.Context, currentTime time.Time) ([]*model.Tweet, error) {
	fmt.Println("currentTime = ", currentTime)
	fmt.Println("len all tweets = ", len(r.Resolver.allTweets))
	var tweets []*model.Tweet
	for _, t := range r.Resolver.allTweets {
		if t.TimeStamp != nil && currentTime.After(*t.TimeStamp) {
			tweets = append(tweets, t)
		}
	}

	return tweets, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
