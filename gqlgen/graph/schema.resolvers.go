package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"time"

	"github.com/google/uuid"
	"github.com/richardimaoka/twitter-clone-2/gqlgen/auth"
	"github.com/richardimaoka/twitter-clone-2/gqlgen/file"
	"github.com/richardimaoka/twitter-clone-2/gqlgen/graph/model"
)

// PostTweet is the resolver for the postTweet field.
func (r *mutationResolver) PostTweet(ctx context.Context, body string) (*model.Tweet, error) {
	tweetId := uuid.New().String()
	userName := "リチャード 伊真岡"
	userId := "richardimaoka"
	profilePicture := "/images/richard-picture.png"
	timeStamp := time.Now()
	time := fmt.Sprintf("%d時%d分", timeStamp.Hour(), timeStamp.Minute())
	date := fmt.Sprintf("%d年%d月%d日", timeStamp.Year(), timeStamp.Month(), timeStamp.Day())

	newTweet := model.Tweet{
		ID:             tweetId,
		UserName:       &userName,
		UserID:         &userId,
		ProfilePicture: &profilePicture,
		Body:           &body,
		// PicturePath
		// PictureWidth
		// PictureHeight
		TimeStamp: &timeStamp,
		Time:      &time,
		Date:      &date,
		// Retweets
		// Quotes
		// Likes
		// Bookmarks
		// Replies
		// Impressions
	}

	r.Resolver.allTweets = append([]*model.Tweet{&newTweet}, r.Resolver.allTweets...)
	fmt.Println("len all tweets = ", len(r.Resolver.allTweets))
	return &newTweet, nil
}

// Like is the resolver for the like field.
func (r *mutationResolver) Like(ctx context.Context, tweetID string) (*model.Tweet, error) {
	log.Printf("like on tweetID = %v", tweetID)
	for _, t := range r.Resolver.allTweets {
		if t.ID == tweetID {
			log.Printf("incrementing like = %d", *t.NumLikes)
			likes := *t.NumLikes
			likes++
			t.NumLikes = &likes
			return t, nil
		}
	}
	return nil, fmt.Errorf("tweet not found")
}

// Tweet is the resolver for the tweet field.
func (r *queryResolver) Tweet(ctx context.Context, tweetID string) (*model.Tweet, error) {
	////////////////////////////////////
	// Get the user from the context
	////////////////////////////////////
	user := auth.ForContext(ctx)
	if user == nil {
		log.Printf("anonymous user is viewing the tweet")
	} else {
		log.Printf("user = %s is viewing the tweet", user.Name)
	}

	////////////////////////////////////
	// Retrieve data
	////////////////////////////////////
	//   time.Sleep(2 * time.Second)
	var tweet *model.Tweet
	var err error
	if os.Getenv("USE_FILE_DATA") == "true" {
		log.Printf("reading tweet from local file")

		tweet, err = file.ReadTweet(tweetID)
		if err != nil {
			log.Printf("failed to read tweet %s, %s", tweetID, err)
			return nil, fmt.Errorf("internal server error")
		}
	} else {
	}

	if tweet == nil {
		log.Printf("tweet not found")
		return nil, fmt.Errorf("tweet not found")
	}

	////////////////////////////////////
	// Permission check
	////////////////////////////////////
	if !canViewTweet(user, tweet) {
		return nil, fmt.Errorf("not authorized to see this tweet")
	}

	return tweet, nil
}

// Timeline is the resolver for the timeline field.
func (r *queryResolver) Timeline(ctx context.Context, currentTime time.Time) ([]*model.Tweet, error) {
	fmt.Println("currentTime = ", currentTime)
	fmt.Println("len all tweets = ", len(r.Resolver.allTweets))
	var tweets []*model.Tweet
	for _, t := range r.Resolver.allTweets {
		if t.TimeStamp != nil && currentTime.After(*t.TimeStamp) {
			tweets = append(tweets, t)
		}
	}

	return tweets, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	filename := "data/me.json"
	bytes, err := os.ReadFile(filename)
	if err != nil {
		log.Printf("failed to read %s, %s", filename, err)
		return nil, fmt.Errorf("internal server error")
	}

	var user model.User
	err = json.Unmarshal(bytes, &user)
	if err != nil {
		log.Printf("failed to unmarshal %s, %s", filename, err)
		return nil, fmt.Errorf("internal server error")
	}

	return &user, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
